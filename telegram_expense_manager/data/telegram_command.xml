<?xml version="1.0" encoding="utf-8"?>
<odoo>
    <record model="telegram.command" id="command_cancel">
        <field name="name">/cancel</field>
        <field name="description">Cancel current command</field>
        <field name="sequence" eval="1000"/>
        <field name="group_ids" eval="[]"/>
        <field name="active" eval="False"/>
        <field name="response_template" type="xml">
            <t>Canceled</t>
</field>
    </record>

    <record model="telegram.command" id="telegram.command_start">
        <field name="response_template" type="xml">
<t>
<t t-if="data['type'] == 'choose_language'">
Choose your language
</t>
<t t-if="data['type'] == 'finish'">
Hi! I am a bot to account expenses, income, plan budgets, etc.
To see examples of my reports simply send command /report_example.
To add new record about an expense, send a text message for example "Dinner 200". You are able to remove any test data by sending command /reset. To get full list of available commands send /help.

I'm at your command!
</t>
</t>
        </field>
        <field name="group_ids" eval="[]"/>
    </record>

    <record model="telegram.command" id="command_about">
        <field name="name">/about</field>
        <field name="description">About me</field>
        <field name="sequence" eval="1000"/>
        <field name="group_ids" eval="[]"/>
        <field name="response_template" type="xml">
            <t>
I was created as an example of usage odoo-telegram library.
https://github.com/it-projects-llc/odoo-telegram

But my master hopes that I could be helpful for folks.
        </t></field>
    </record>


    <record model="telegram.command" id="command_expense">
        <field name="name">%[0-9]+%</field>
        <field name="description">Add new record</field>
        <field name="sequence" eval="1000"/>
        <field name="group_ids" eval="[]"/>
        <field name="response_code">
partner = env.user.partner_id
callback_data =  telegram.get('callback_data')
raw_text = telegram['tmessage'].text
error = None
if callback_data:
    record, error = partner.em_handle_callback_data(callback_data, raw_text)
else:
    # create new record

    m = re.match(r'(.*?) ([0-9.,]*) ?(.*)', telegram['tmessage'].text)
    text = m.group(1)
    amount = m.group(2)
    currency = m.group(3)

    record = partner.sudo().em_add_expense_record(text, amount, currency)

if not error:
    analytic_liquidity = record.em_get_analytic_liquidity()
    analytic_payable = record.em_get_analytic_payable()

    if not analytic_liquidity:
        data['type'] = 'no_analytic_liquidity'
        partner.em_ask_analytic(options, command, record, command.TAG_LIQUIDITY)

    elif not analytic_payable:

        data['type'] = 'no_analytic_payable'
        buttons = partner.em_ask_analytic(options, command, record, command.TAG_PAYABLE)
        if buttons:
            data['subtype'] = 'choose_or_create_analytic'
        else:
            data['subtype'] = 'create_analytic'

    data['analytic_liquidity'] = analytic_liquidity
    data['analytic_payable'] = analytic_payable
    data['record'] = record
        </field>
        <field name="response_template" type="xml">
<t>
    <t t-if="data.get('type') == 'no_analytic_liquidity'">Choose payment way or send name for new one</t>
    <t t-elif="data.get('type') == 'no_analytic_payable'">
        <t t-if="data.get('subtype') == 'choose_or_create_analytic'">Choose expense category or send name for new one</t>
        <t t-if="data.get('subtype') == 'create_analytic'">Specify a name for expense category (e.g. Food, Cafe, etc)</t>
    </t>
    <t t-else="">New record is added! Check or edit it here: /record_<t t-esc="data['record'].id"/></t>
</t>
        </field>
        <field name="active" eval="False"/>
    </record>

    <record model="telegram.command" id="command_income">
        <field name="name">/income</field>
        <field name="description">Add new income record</field>
        <field name="sequence" eval="1000"/>
        <field name="group_ids" eval="[]"/>
        <field name="response_code">

partner = env.user.partner_id
callback_data =  telegram.get('callback_data')
raw_text = telegram['tmessage'].text

record = None
if not callback_data:
    # initial /income request
    partner.em_ask_amount(options, command, None)
    data['type'] = 'ask_amount'
else:
    record, error = partner.em_handle_callback_data(callback_data, raw_text, add_record=partner.em_add_income_record)

    if not error:
        analytic_liquidity = record.em_get_analytic_liquidity()
        analytic_receivable = record.em_get_analytic_receivable()

        if not analytic_receivable:
            data['type'] = 'no_analytic_receivable'
            buttons = partner.em_ask_analytic(options, command, record, command.TAG_RECEIVABLE)
            data['analytic_receivable_count'] = len(buttons)
        elif not analytic_liquidity:
            if analytic_receivable.liquidity_id:
                data['type'] = 'done'
                record.em_update_analytic_liquidity(analytic_receivable.liquidity_id)
            else:
                data['type'] = 'no_analytic_liquidity'
                partner.em_ask_analytic(options, command, record, command.TAG_LIQUIDITY)
        else:
            data['type'] = 'done'
data['record'] = record
        </field>
        <field name="response_template" type="xml">
<t>
    <t t-if="data.get('type') == 'ask_amount'">Send amount of money</t>
    <t t-elif="data.get('type') == 'no_analytic_liquidity'">Choose payment way or send name for new one</t>
    <t t-elif="data.get('type') == 'no_analytic_receivable'">
        <t t-if="data.get('analytic_receivable_count')">Choose income category or send name for new one</t>
        <t t-else="">Specify a name for income category (e.g. Salary, Advance Payment, etc)</t>
    </t>
    <t t-else="">New Income record is added! Check or edit it here: /record_<t t-esc="data['record'].id"/></t>
</t>
        </field>
    </record>

    <record model="telegram.command" id="command_transfer">
        <field name="name">/transfer</field>
        <field name="description">Add new transfer record</field>
        <field name="sequence" eval="1000"/>
        <field name="group_ids" eval="[]"/>
        <field name="response_code">

partner = env.user.partner_id
callback_data =  telegram.get('callback_data')
raw_text = telegram['tmessage'].text

record = None
if not callback_data:
    # initial /transfer request
    partner.em_ask_amount(options, command, None)
    data['type'] = 'ask_amount'
else:
    record, error = partner.em_handle_callback_data(callback_data, raw_text, add_record=partner.em_add_transfer_record)
    if not error:
        analytic_from = record.em_get_analytic_from()
        analytic_to = record.em_get_analytic_to()

        if not analytic_from:
            data['type'] = 'no_analytic_from'
            partner.em_ask_analytic(options, command, record, command.TAG_LIQUIDITY, is_from=True)
        elif not analytic_to:
            data['type'] = 'no_analytic_to'
            partner.em_ask_analytic(options, command, record, command.TAG_LIQUIDITY, is_to=True)
        else:
            data['type'] = 'done'

data['record'] = record
        </field>
        <field name="response_template" type="xml">
<t>
    <t t-if="data.get('type') == 'ask_amount'">Send amount of money</t>
    <t t-elif="data.get('type') == 'no_analytic_from'">Choose Source</t>
    <t t-elif="data.get('type') == 'no_analytic_to'">Choose Destination</t>
    <t t-else="">Money are transfered /record_<t t-esc="data['record'].id"/>! To check current amounts in all account use command /accounts. To schedule automatic transfers use /schedule</t>
</t>
        </field>
    </record>

    <record model="telegram.command" id="command_record">
        <field name="name">/record_%</field>
        <field name="description">Check/Edit specific record</field>
        <field name="sequence" eval="800"/>
        <field name="universal" eval="False"/>
        <field name="active" eval="False"/>
        <field name="group_ids" eval="[]" />
        <field name="response_code">
ACTION='a'
EDIT_AMOUNT='am'
EDIT_ANALYTIC='an'
EDIT_NOTE='en'
EMPTY_ACTION='n'
RECORD_ID='r'
LINE_ID='l'
NEW_ANALYTIC_ID='na'

callback_data = telegram.get('callback_data')
partner = env.user.partner_id
raw_text = telegram.get('tmessage') and telegram.get('tmessage').text
record_id = callback_data and callback_data.get(RECORD_ID) or raw_text and '_' in raw_text and int(raw_text.split('_')[1])
record = partner.em_browse_record(record_id) if record_id else None
data['record'] = record

def edit_button(action, text, record, line_id=None):
    ACTION='a'
    RECORD_ID='r'
    LINE_ID='l'
    icon = emoji.emojize(':pencil:', use_aliases=True)
    button = {
           'text': '%s %s' % (icon, text),
           'callback_data': {
               ACTION: action,
               RECORD_ID: record.id,
           }}
    if line_id:
        button['callback_data'][LINE_ID] = line_id
    return button

def text_button(text, record):
    ACTION='a'
    RECORD_ID='r'
    icon = emoji.emojize(':pencil:', use_aliases=True)
    button = {
           'text': text,
           'callback_data': {
               ACTION: EMPTY_ACTION,
               RECORD_ID: record.id,
           }}
    return button

if not callback_data:
    # handle initial /record_1234 request
    lines = record.em_lines()
    command.inline_keyboard_buttons(options, [
        edit_button(
            EDIT_AMOUNT,
            _('Amount: %s') % record.amount,
            record),
        edit_button(
            EDIT_NOTE,
            _('Note: %s') % record.narration,
            record),
    ] + [
        edit_button(
            EDIT_ANALYTIC,
            label % lines[key]['analytic'],
            record,
            lines[key]['id'])
        for label, key in [
            (_('Source: %s'), 'from'),
            (_('Destination: %s'), 'to'),
        ]
        if lines.get(key)
    ], row_width=1)
    data['type'] = 'show_record'
elif callback_data.get(ACTION) == EMPTY_ACTION:
    # ignore request
    pass

elif telegram.get('callback_type') == 'inline':
    # handle click on "edit" buttons
    if callback_data.get(ACTION) == EDIT_AMOUNT:
        data['type'] = 'edit_amount'
        partner.em_ask_amount(options, command, record)
    elif callback_data.get(ACTION) == EDIT_NOTE:
        data['type'] = 'edit_note'
        partner.em_ask_note(options, command, record)
    elif callback_data.get(ACTION) == EDIT_ANALYTIC:
        line_id = callback_data.get(LINE_ID)
        line = partner.em_browse_line(line_id)
        tag = line._em_analytic_tag()
        data['type'] = 'edit_from' if line.is_from else 'edit_to'
        partner.em_ask_analytic(options, command, record, tag)
else:
    # handle new value of attributes (either click on Reply Keyboard or manual typing)
    data['type'] = 'updated'
    record, error = partner.em_handle_callback_data(callback_data, raw_text)
    data['record'] = record
        </field>
        <field name="response_template" type="xml">
<t>
    <t t-if="data['type'] == 'show_record'">Record #<t t-esc="data['record'].id"/>. You can delete it by sending /delete_<t t-esc="data['record'].id"/>.</t>
    <t t-if="data['type'] == 'edit_amount'">Send new Amount or click /cancel</t>
    <t t-if="data['type'] == 'edit_note'">Send new Note or click /cancel</t>
    <t t-if="data['type'] == 'edit_from'">Send new Source, choose from existing or click /cancel</t>
    <t t-if="data['type'] == 'edit_to'">Send new Destination, choose from existing or click /cancel</t>
    <t t-if="data['type'] == 'updated'">Done! /record_<t t-esc="data['record'].id"/> is updated.</t>
</t>
        </field>
    </record>


    <record model="telegram.command" id="command_accounts">
        <field name="name">/accounts</field>
        <field name="description">Report on accounts</field>
        <field name="sequence" eval="1000"/>
        <field name="group_ids" eval="[]"/>
        <field name="response_code">

partner = env.user.partner_id
accounts = env["account.analytic.account"].sudo().search(
    [('partner_id', '=', partner.id),
     ('tag_ids', '=', env.ref(command.TAG_LIQUIDITY).id)])
domain = [('partner_id', '=', partner.id),
          ('analytic_account_id', 'in', accounts.ids),
         ]
res = env["account.move.line"].sudo().read_group(
    domain,
    ["name", "balance", "analytic_account_id"],
    ["analytic_account_id"],
    )

accounts_index = dict( [(acc.id, acc.name) for acc in accounts] )
accounts_data = [{"name": accounts_index.get(obj['analytic_account_id'][0], 'UNDEFINED'),
                  "id": obj['analytic_account_id'][0],
                  "balance": obj['balance'],
                  } for obj in res]
accounts_data = sorted(accounts_data, key=lambda obj: obj['id'])
data['accounts'] = accounts_data
        </field>
        <field name="response_template" type="xml">
            <t t-foreach="data['accounts']" t-as="acc">
/account_<t t-esc="acc['id']"/> <t t-esc="acc['name']"/>: <t t-esc="acc['balance']"/></t>
        </field>
    </record>


</odoo>
